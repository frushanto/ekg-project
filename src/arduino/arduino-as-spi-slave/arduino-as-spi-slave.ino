/********************************************************
(1)  DPin-10 takes over the symbolic name SS 
(Slave Select) and gets configures as output 
line with value logic-high.

This SS line is connected with the SS/-pin (if 
there is any) of the Slave NANO. To select the 
Slave, the Master must assert logic-low (LL) on 
the SS/-pin. The user may drive the SS/-pin of 
the Slave to logic-low state by using any other 
digital pin of the Master. 

(2)  DPin-11 takes over the symbolic name MOSI 
(Master Out Slave In) and gets configures as output 
line with value logic-low.

(3)  DPin-12 takes over the symbolic name MISO 
(Master In Slave Out) and gets configures as input 
line.

(4)  DPin-13 takes over the symbolic name SCK (Serial
Clock) configures as output line with value logic-low 
(Mode-1 operation: CPOL = LOW, CPHA = FALLING).

(5)  The default data transfer speed is 4 MBits/sec.
The speed can be changed using this code: 
SPI.setClockDivider();.

3.  In the SPI Slave sketch, we include the SPI.h 
Library; but, we don't include the SPI.begin() 
instruction. The inclusion of the SPI.h Library helps 
to use use the following symbolic names and function 
of the Library:

(1)  SS: Slave Select which does refer to DPin-10 of 
the Slave. To enable the 'SPI Port' of the Slave, we 
must configure its direction as input so that the SPI 
Master can assert logic-low signal on this pin to 
select (enable Slave's SPI Port) the Slave for data 
communication.

(2)  MOSI: Master Out Slave In which does refer to 
DPin-11 of the Slave. We must set its direction as 
input so that data coming from Master can enter into 
the SPDR Register of the Slave.

(3)  MISO: Master In Slave Out which does refer to 
DPin-12 of the Slave. We must set its direction as 
output so that data leaving the Slave can enter into 
the SPDR Register of the Master.

(4)  SPI.attachInterrupt(): This function/method 
enables the interrupt logic of the SPI Port of the 
Slave. The result is this: whenever a data bytes enters 
into the SPDR register of the Slave, the Slave is 
automatically interrupted; it goes to interrupt handler 
(the ISR) and spends very short time there either to 
collect data from the SPDR Register or to set a flag to 
enable the MCU to collect data in the loop() function. 

(5)  SCK: Serial Clock which does refer to DPin-13 of 
the Slave. We must set its direction as input so that 
the serial clock signal generated by Master can 
simultaneously 'clock out' data from its SPDR Register 
and 'clock in' the same data into SPDR Register of the 
Slave. This is reason for saying that SPI stands for 
'Synchronous Serial Peripheral Interface'. 
********************************************************/

#include<SPI.h>
volatile int i = 0;
byte myArray[2];

void setup()
{
  Serial.begin(115200);
  Serial.print("Setup begin\n");
  pinMode(SS, INPUT_PULLUP);
  pinMode(MOSI, OUTPUT);
  pinMode(SCK, INPUT);
  SPCR |= _BV(SPE);
  SPI.attachInterrupt();  //allows SPI interrupt
  Serial.print("Setup end\n");
}

void loop(void)
{
  if (i == 2)
  {
    int x = (int)myArray[0]<<8|(int)myArray[1];
    Serial.print("Received 16-bit data item from Master: ");
    Serial.println(x, HEX);
    i=0;
    Serial.println("=============================================");
  }
}

ISR (SPI_STC_vect)   //Inerrrput routine function
{
  //Serial.print("ISR\n");
  myArray[i] = SPDR;
  i++;
}
